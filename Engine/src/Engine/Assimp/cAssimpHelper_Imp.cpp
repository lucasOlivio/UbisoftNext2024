#include "pch.h"
#include "cFileLoader_Imp.h"

//#include <iostream>

#include <assimp/Importer.hpp>      // C++ importer interface
#include <assimp/scene.h>           // Output data structure
#include <assimp/postprocess.h>     // Post processing flags

// Note: Depending on the library, you have to use the specific config.h
// file from the lib folder. This is generated by CMake.
// This config is VS22vc143x64static

#include <sstream>
#include <float.h>
#include <fstream>
#include <glm/vec3.hpp>

namespace MyEngine
{
	cFileLoader_Imp::cFileLoader_Imp()
	{

	}

	cFileLoader_Imp::~cFileLoader_Imp()
	{

	}

	bool cFileLoader_Imp::m_ProcessScene(const aiScene* scene, sMesh* drawInfo)
	{
		// TODO: Validation of meshes and diferent objects loading
		for (unsigned int index = 0; index < scene->mNumMeshes; index++)
		{
			aiMesh* currMesh = scene->mMeshes[index];

			// Set basic data for the structure
			drawInfo->numberOfIndices += currMesh->mNumFaces * currMesh->mFaces[0].mNumIndices; // Get # of indices total based on the first face element
			drawInfo->numberOfTriangles += currMesh->mNumFaces;
			drawInfo->numberOfVertices += currMesh->mNumVertices;
		}
		// Load the triangles for organize structure
		drawInfo->pTriangles = new sTriangle[drawInfo->numberOfTriangles];
		// Load the vertices in the opengl structure VBO
		drawInfo->pVertices = new sVertex[drawInfo->numberOfVertices];
		// Load the indices for the Index Buffer
		drawInfo->pIndices = new unsigned int[drawInfo->numberOfIndices];

		float minX = FLT_MAX;
		float minY = minX;
		float minZ = minX;
		float maxX = FLT_MIN;
		float maxY = maxX;
		float maxZ = maxX;
		for (unsigned int index = 0; index < scene->mNumMeshes; index++)
		{
			aiMesh* currMesh = scene->mMeshes[index];

			// Load the vertices in the opengl structure VBO
			for (unsigned int currMeshIndex = 0; currMeshIndex < drawInfo->numberOfVertices; currMeshIndex++)
			{
				unsigned int vboIndex = currMeshIndex + (index * currMeshIndex); // Allocate all in sequence in the array
				drawInfo->pVertices[vboIndex].x = currMesh->mVertices[currMeshIndex].x;
				drawInfo->pVertices[vboIndex].y = currMesh->mVertices[currMeshIndex].y;
				drawInfo->pVertices[vboIndex].z = currMesh->mVertices[currMeshIndex].z;
				drawInfo->pVertices[vboIndex].w = 1.0f;

				// Check if mesh have normals
				if (currMesh->HasNormals())
				{
					drawInfo->pVertices[vboIndex].nx = currMesh->mNormals[currMeshIndex].x;
					drawInfo->pVertices[vboIndex].ny = currMesh->mNormals[currMeshIndex].y;
					drawInfo->pVertices[vboIndex].nz = currMesh->mNormals[currMeshIndex].z;
					drawInfo->pVertices[vboIndex].nw = 1.0f;
				}

				// Check if mesh have vertex colors
				if (currMesh->HasVertexColors(currMeshIndex))
				{
					drawInfo->pVertices[vboIndex].r = currMesh->mColors[0][currMeshIndex].r;
					drawInfo->pVertices[vboIndex].g = currMesh->mColors[0][currMeshIndex].g;
					drawInfo->pVertices[vboIndex].b = currMesh->mColors[0][currMeshIndex].b;
					drawInfo->pVertices[vboIndex].a = currMesh->mColors[0][currMeshIndex].a;
				}

				// Check if mesh have texture coordinates
				if (currMesh->mNumUVComponents[0] > 0)
				{
					drawInfo->pVertices[vboIndex].u = currMesh->mTextureCoords[0][currMeshIndex].x;
					drawInfo->pVertices[vboIndex].v = currMesh->mTextureCoords[0][currMeshIndex].y;
				}

				// Get mesh info
				if (drawInfo->pVertices[vboIndex].x < minX)
				{
					minX = drawInfo->pVertices[vboIndex].x;
				}
				if (drawInfo->pVertices[vboIndex].y < minY)
				{
					minY = drawInfo->pVertices[vboIndex].y;
				}
				if (drawInfo->pVertices[vboIndex].z < minZ)
				{
					minZ = drawInfo->pVertices[vboIndex].z;
				}

				if (drawInfo->pVertices[vboIndex].x > maxX)
				{
					maxX = drawInfo->pVertices[vboIndex].x;
				}
				if (drawInfo->pVertices[vboIndex].y > maxY)
				{
					maxY = drawInfo->pVertices[vboIndex].y;
				}
				if (drawInfo->pVertices[vboIndex].z > maxZ)
				{
					maxZ = drawInfo->pVertices[vboIndex].z;
				}
			}

			// Load the indices for the Index Buffer
			// TODO: Load different indices numbers based on shape (For now we just will use triangles)

			for (unsigned int currTriangleIndex = 0;
				currTriangleIndex < drawInfo->numberOfTriangles;
				currTriangleIndex++)
			{
				// Jump every 3 vertex index
				unsigned int indicesIndex = currTriangleIndex * 3;

				int v1 = currMesh->mFaces[currTriangleIndex].mIndices[0];
				int v2 = currMesh->mFaces[currTriangleIndex].mIndices[1];
				int v3 = currMesh->mFaces[currTriangleIndex].mIndices[2];

				drawInfo->pIndices[indicesIndex] = v1;
				indicesIndex += 1;
				drawInfo->pIndices[indicesIndex] = v2;
				indicesIndex += 1;
				drawInfo->pIndices[indicesIndex] = v3;
				indicesIndex += 1;

				// Load vertices positions into triangles
				drawInfo->pTriangles[currTriangleIndex].vertices[0] = glm::vec3(drawInfo->pVertices[v1].x,
					drawInfo->pVertices[v1].y,
					drawInfo->pVertices[v1].z);
				drawInfo->pTriangles[currTriangleIndex].vertices[1] = glm::vec3(drawInfo->pVertices[v2].x,
					drawInfo->pVertices[v2].y,
					drawInfo->pVertices[v2].z);
				drawInfo->pTriangles[currTriangleIndex].vertices[2] = glm::vec3(drawInfo->pVertices[v3].x,
					drawInfo->pVertices[v3].y,
					drawInfo->pVertices[v3].z);
			}
		}
		drawInfo->minX = minX;
		drawInfo->minY = minY;
		drawInfo->minZ = minZ;
		drawInfo->maxX = maxX;
		drawInfo->maxY = maxY;
		drawInfo->maxZ = maxZ;

		return true;
	}

	bool cFileLoader_Imp::Load3DModelFile(std::string filename, cFileLoader::sPostProcessFlags postProcessOptions, sMesh* drawInfo)
	{
		std::string filename_and_path = filename;

		if (this->m_basePath_no_end_slash != "")
		{
			filename_and_path = this->m_basePath_no_end_slash + '/' + filename;
		}

		// Translate the boolean helper flags to the assimp post processing flags
		unsigned int assimpPostProcessingFlags = this->m_loadAssimpPostProcessingFlags(postProcessOptions);

		// This is from the assimp help documentation
		// Create an instance of the Importer class
		Assimp::Importer importer;
		// And have it read the given file with some example postprocessing
		// Usually - if speed is not the most important aspect for you - you'll 
		// propably to request more postprocessing than we do in this example.
		const aiScene* scene = importer.ReadFile(filename_and_path.c_str(), assimpPostProcessingFlags);

		// If the import failed, report it
		if (!scene)
		{
			std::string errorString(importer.GetErrorString());
			this->m_AppendErrorString(errorString);
			return false;
		}
		// Now we can access the file's contents. 

		ass_cScene theScene;
		theScene.scene_flags.DecodeSceneFlags(scene->mFlags);

		this->m_ProcessScene(scene, drawInfo);
		// We're done. Everything will be cleaned up by the importer destructor
		importer.FreeScene();
		return true;
	}

	unsigned int cFileLoader_Imp::m_loadAssimpPostProcessingFlags(cFileLoader::sPostProcessFlags postProcessOptions)
	{
		unsigned int assimpPostProcessingFlags = 0;

		if (postProcessOptions.bProcess_CalcTangentSpace)
		{
			assimpPostProcessingFlags |= aiProcess_CalcTangentSpace;
		}
		if (postProcessOptions.bProcess_CalcTangentSpace)
		{
			assimpPostProcessingFlags |= aiProcess_CalcTangentSpace;
		}
		if (postProcessOptions.bProcess_JoinIdenticalVertices)
		{
			assimpPostProcessingFlags |= aiProcess_JoinIdenticalVertices;
		}
		if (postProcessOptions.bProcess_MakeLeftHanded)
		{
			assimpPostProcessingFlags |= aiProcess_MakeLeftHanded;
		}
		if (postProcessOptions.bProcess_Triangulate)
		{
			assimpPostProcessingFlags |= aiProcess_Triangulate;
		}
		if (postProcessOptions.bProcess_RemoveComponent)
		{
			assimpPostProcessingFlags |= aiProcess_RemoveComponent;
		}
		if (postProcessOptions.bProcess_GenNormals)
		{
			assimpPostProcessingFlags |= aiProcess_GenNormals;
		}
		if (postProcessOptions.bProcess_GenSmoothNormals)
		{
			assimpPostProcessingFlags |= aiProcess_GenSmoothNormals;
		}
		if (postProcessOptions.bProcess_SplitLargeMeshes)
		{
			assimpPostProcessingFlags |= aiProcess_SplitLargeMeshes;
		}
		if (postProcessOptions.bProcess_PreTransformVertices)
		{
			assimpPostProcessingFlags |= aiProcess_PreTransformVertices;
		}
		if (postProcessOptions.bProcess_LimitBoneWeights)
		{
			assimpPostProcessingFlags |= aiProcess_LimitBoneWeights;
		}
		if (postProcessOptions.bProcess_ValidateDataStructure)
		{
			assimpPostProcessingFlags |= aiProcess_ValidateDataStructure;
		}
		if (postProcessOptions.bProcess_ImproveCacheLocality)
		{
			assimpPostProcessingFlags |= aiProcess_ImproveCacheLocality;
		}
		if (postProcessOptions.bProcess_RemoveRedundantMaterials)
		{
			assimpPostProcessingFlags |= aiProcess_RemoveRedundantMaterials;
		}
		if (postProcessOptions.bProcess_FixInfacingNormals)
		{
			assimpPostProcessingFlags |= aiProcess_FixInfacingNormals;
		}
		if (postProcessOptions.bProcess_SortByPType)
		{
			assimpPostProcessingFlags |= aiProcess_SortByPType;
		}
		if (postProcessOptions.bProcess_FindDegenerates)
		{
			assimpPostProcessingFlags |= aiProcess_FindDegenerates;
		}
		if (postProcessOptions.bProcess_FindInvalidData)
		{
			assimpPostProcessingFlags |= aiProcess_FindInvalidData;
		}
		if (postProcessOptions.bProcess_GenUVCoords)
		{
			assimpPostProcessingFlags |= aiProcess_GenUVCoords;
		}
		if (postProcessOptions.bProcess_TransformUVCoords)
		{
			assimpPostProcessingFlags |= aiProcess_TransformUVCoords;
		}
		if (postProcessOptions.bProcess_FindInstances)
		{
			assimpPostProcessingFlags |= aiProcess_FindInstances;
		}
		if (postProcessOptions.bProcess_OptimizeMeshes)
		{
			assimpPostProcessingFlags |= aiProcess_OptimizeMeshes;
		}
		if (postProcessOptions.bProcess_OptimizeGraph)
		{
			assimpPostProcessingFlags |= aiProcess_OptimizeGraph;
		}
		if (postProcessOptions.bProcess_FlipUVs)
		{
			assimpPostProcessingFlags |= aiProcess_FlipUVs;
		}
		if (postProcessOptions.bProcess_FlipWindingOrder)
		{
			assimpPostProcessingFlags |= aiProcess_FlipWindingOrder;
		}
		if (postProcessOptions.bProcess_SplitByBoneCount)
		{
			assimpPostProcessingFlags |= aiProcess_SplitByBoneCount;
		}
		if (postProcessOptions.bProcess_Debone)
		{
			assimpPostProcessingFlags |= aiProcess_Debone;
		}

		return assimpPostProcessingFlags;
	}


	std::string cFileLoader_Imp::getLastError(bool bAndClearErrors /*=true*/)
	{
		std::string error = this->m_LastError;

		if (bAndClearErrors)
		{
			this->m_LastError = "";
		}
		return error;
	}

	void cFileLoader_Imp::m_AppendErrorString(std::string errorString)
	{
		std::stringstream ssError;
		if (!this->m_LastError.empty())
		{
			ssError << this->m_LastError;
			ssError << std::endl;
		}
		ssError << errorString;
		this->m_LastError = ssError.str();
		return;
	}


	void cFileLoader_Imp::SetBasePath(std::string basepath_no_end_slash)
	{
		this->m_basePath_no_end_slash = basepath_no_end_slash;
		return;
	}
}
